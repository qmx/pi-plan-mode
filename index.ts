/**
 * Plan Mode Extension
 *
 * A read-only exploration mode for safe code analysis and planning.
 *
 * Features:
 * - /plan command to toggle plan mode
 * - read-only tools: read, bash, grep, find, ls, questionnaire
 * - edit/write allowed for plan file only
 * - User-only exit (LLM cannot exit plan mode)
 * - Auto-creates plan file at ~/.pi/agent/plans/<session>/<name>.md
 *
 * Differences from @juanibiapina/pi-plan:
 * - Exiting plan mode is 100% user-controlled (via /plan command only)
 * - Plans are saved automatically to ~/.pi/agent/plans/<session-folder>/<name>.md
 * - edit/write tools work for the plan file in plan mode
 */

import * as fs from "node:fs";
import * as path from "node:path";
import * as os from "node:os";
import type { ExtensionAPI, ExtensionContext } from "@mariozechner/pi-coding-agent";
import { Key } from "@mariozechner/pi-tui";
import { isSafeCommand } from "./utils.js";

// Tools available in plan mode (read-only + plan file edit/write)
const PLAN_MODE_TOOLS = ["read", "bash", "grep", "find", "ls", "questionnaire", "edit", "write"];
// Tools available in normal mode
const NORMAL_MODE_TOOLS = ["read", "bash", "edit", "write", "grep", "find", "ls"];

// Get the plans directory path
function getPlansDir(): string {
	return path.join(os.homedir(), ".pi", "agent", "plans");
}

// Get the session folder name from session file path
function getSessionFolder(sessionFile: string | null): string {
	if (!sessionFile) {
		return "ephemeral";
	}
	// Extract folder name from session path
	// Format: ~/.pi/agent/sessions/--<path>--/<timestamp>_<uuid>.jsonl
	const match = sessionFile.match(/sessions\/(--.+?--)\//);
	if (match) {
		// Decode the path (--<path>-- where / is replaced with -)
		return match[1].replace(/^--/, "").replace(/--$/, "");
	}
	return "unknown";
}

// Generate a random plan file name
function generatePlanName(): string {
	const adjectives = ["quick", "detailed", "initial", "revised", "final", "draft", "analysis", "exploratory"];
	const nouns = ["plan", "approach", "strategy", "roadmap", "outline", "proposal", "notes", "review"];
	const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
	const noun = nouns[Math.floor(Math.random() * nouns.length)];
	const timestamp = Date.now().toString(36).slice(-6);
	return `${adj}-${noun}-${timestamp}.md`;
}

export default function planModeExtension(pi: ExtensionAPI): void {
	let planModeEnabled = false;
	let currentPlanPath: string | null = null;

	pi.registerFlag("plan", {
		description: "Start in plan mode (read-only exploration)",
		type: "boolean",
		default: false,
	});

	function updateStatus(ctx: ExtensionContext): void {
		if (planModeEnabled) {
			let statusText = ctx.ui.theme.fg("warning", "â¸ plan");
			if (currentPlanPath) {
				const homeDir = os.homedir();
				let displayPath = currentPlanPath;
				if (displayPath.startsWith(homeDir)) {
					displayPath = "~" + displayPath.slice(homeDir.length);
				}
				statusText += ctx.ui.theme.fg("dim", ` - ${displayPath}`);
			}
			ctx.ui.setStatus("plan-mode", statusText);
		} else {
			ctx.ui.setStatus("plan-mode", undefined);
		}
	}

	function togglePlanMode(ctx: ExtensionContext): void {
		planModeEnabled = !planModeEnabled;

		if (planModeEnabled) {
			pi.setActiveTools(PLAN_MODE_TOOLS);

			// Create plan file
			const sessionFile = ctx.sessionManager.getSessionFile();
			const sessionFolder = getSessionFolder(sessionFile);
			const plansDir = path.join(getPlansDir(), sessionFolder);
			const planFileName = generatePlanName();
			currentPlanPath = path.join(plansDir, planFileName);

			try {
				fs.mkdirSync(plansDir, { recursive: true });
				const header = `# Plan\n\n*Session: ${sessionFolder}*\n*Generated by pi plan-mode extension*\n\n---\n\n`;
				fs.writeFileSync(currentPlanPath, header, "utf-8");
				ctx.ui.notify(`Plan file created: ${currentPlanPath}`, "info");
			} catch (error) {
				const errorMessage = error instanceof Error ? error.message : String(error);
				ctx.ui.notify(`Failed to create plan file: ${errorMessage}`, "error");
				currentPlanPath = null;
			}

			ctx.ui.notify(`Plan mode enabled. Tools available: read, bash, grep, find, ls, questionnaire, edit, write (plan file only)`, "info");
		} else {
			pi.setActiveTools(NORMAL_MODE_TOOLS);
			currentPlanPath = null;
			ctx.ui.notify("Plan mode disabled. Full tool access restored.", "success");
		}
		updateStatus(ctx);
		persistState();
	}

	function persistState(): void {
		pi.appendEntry("plan-mode", {
			enabled: planModeEnabled,
			planPath: currentPlanPath,
		});
	}

	// Register /plan command - user-only way to toggle plan mode
	pi.registerCommand("plan", {
		description: "Toggle plan mode (read-only exploration)",
		handler: async (_args, ctx) => togglePlanMode(ctx),
	});

	// Register shortcut Ctrl+Alt+P
	pi.registerShortcut(Key.ctrlAlt("p"), {
		description: "Toggle plan mode",
		handler: async (ctx) => togglePlanMode(ctx),
	});

	// Block destructive bash commands and restrict edit/write to plan file only in plan mode
	pi.on("tool_call", async (event) => {
		if (!planModeEnabled) return;

		// Block destructive bash commands
		if (event.toolName === "bash") {
			const command = event.input.command as string;
			if (!isSafeCommand(command)) {
				return {
					block: true,
					reason: `Plan mode: command blocked (not allowlisted). Use /plan to disable plan mode first.\nCommand: ${command}`,
				};
			}
		}

		// Restrict edit/write to plan file only
		if ((event.toolName === "edit" || event.toolName === "write") && currentPlanPath) {
			const targetPath = event.input.path as string;
			if (targetPath !== currentPlanPath) {
				return {
					block: true,
					reason: `Plan mode: can only ${event.toolName} the plan file. Use /plan to disable plan mode first.\nTarget: ${targetPath}\nAllowed: ${currentPlanPath}`,
				};
			}
		}
	});

	// Inject plan mode context before agent starts
	pi.on("before_agent_start", async () => {
		if (!planModeEnabled) return;

		const planPathDisplay = currentPlanPath
			? currentPlanPath.replace(os.homedir(), "~")
			: "(no plan file)";

		return {
			message: {
				customType: "plan-mode-context",
				content: `[PLAN MODE ACTIVE]
You are in PLAN MODE - a read-only exploration mode for safe code analysis.

Restrictions:
- You can only use: read, bash, grep, find, ls, questionnaire, edit, write
- edit/write restricted to plan file only: ${planPathDisplay}
- Bash is restricted to allowlisted read-only commands

Your goal is to:
1. Explore and understand the codebase
2. Analyze the requirements
3. Create and edit a detailed plan

IMPORTANT: You CANNOT exit plan mode. The user must manually exit using the /plan command. Do not ask the user to exit plan mode - focus on creating your analysis and plan.`,
				display: false,
			},
		};
	});

	// Restore state on session start/resume
	pi.on("session_start", async (_event, ctx) => {
		// Check CLI flag first
		if (pi.getFlag("plan") === true) {
			planModeEnabled = true;
		}

		const entries = ctx.sessionManager.getEntries();

		// Restore persisted state
		const planModeEntry = entries
			.filter((e: { type: string; customType?: string }) => e.type === "custom" && e.customType === "plan-mode")
			.pop() as { data?: { enabled: boolean; planPath?: string } } | undefined;

		if (planModeEntry?.data) {
			planModeEnabled = planModeEntry.data.enabled ?? planModeEnabled;
			currentPlanPath = planModeEntry.data.planPath ?? null;
		}

		if (planModeEnabled) {
			pi.setActiveTools(PLAN_MODE_TOOLS);
		}
		updateStatus(ctx);
	});
}
